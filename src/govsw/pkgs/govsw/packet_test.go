// -*- coding: utf-8 -*-

// Copyright (C) 2019 Nippon Telegraph and Telephone Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package govsw

import (
	"bytes"
	"testing"
)

func TestParsePacketNoVlan(t *testing.T) {
	data := []byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x19,
		0x06, 0xea, 0xb8, 0xc1, 0x08, 0x06, 0x00, 0x01,
		0x08, 0x00, 0x06, 0x04, 0x00, 0x02, 0x00, 0x19,
		0x06, 0xea, 0xb8, 0xc1, 0xc0, 0xa8, 0x7b, 0x01,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xa8,
		0x7b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	pkt, err := ParsePacket(data, 1)
	if err != nil {
		t.Errorf("ParsePAcker error. %s", err)
	}
	if pkt.Ffpkt != nil {
		t.Errorf("ParsePacket unmatch. ffpkt=%v", pkt.Ffpkt)
	}
	if v := bytes.Compare(pkt.Data, data); v != 0 {
		t.Errorf("ParsePacket unmatch. cmp=%v", v)
	}
}

func TestParsePacketVlan1(t *testing.T) {
	data := []byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x19,
		0x06, 0xea, 0xb8, 0xc1, 0x81, 0x00, 0x00, 0x01,
		0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04,
		0x00, 0x02, 0x00, 0x19, 0x06, 0xea, 0xb8, 0xc1,
		0xc0, 0xa8, 0x7b, 0x01, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xc0, 0xa8, 0x7b, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	data1 := []byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x19,
		0x06, 0xea, 0xb8, 0xc1, 0x08, 0x06, 0x00, 0x01,
		0x08, 0x00, 0x06, 0x04, 0x00, 0x02, 0x00, 0x19,
		0x06, 0xea, 0xb8, 0xc1, 0xc0, 0xa8, 0x7b, 0x01,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xa8,
		0x7b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	pkt, err := ParsePacket(data, 1)
	if err != nil {
		t.Errorf("ParsePAcker error. %s", err)
	}
	if pkt.Ffpkt != nil {
		t.Errorf("ParsePacket unmatch. ffpkt=%v", pkt.Ffpkt)
	}
	if v := pkt.Data; v == nil {
		t.Errorf("ParsePacket unmatch. data=%v", v)
	}
	if v := bytes.Compare(pkt.Data, data1); v != 0 {
		t.Errorf("ParsePacket unmatch. cmp=%v", v)
	}
}

func TestParsePacketVlanN(t *testing.T) {
	data := []byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x19,
		0x06, 0xea, 0xb8, 0xc1, 0x81, 0x00, 0x00, 0x02,
		0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04,
		0x00, 0x02, 0x00, 0x19, 0x06, 0xea, 0xb8, 0xc1,
		0xc0, 0xa8, 0x7b, 0x01, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xc0, 0xa8, 0x7b, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	pkt, err := ParsePacket(data, 1)
	if err != nil {
		t.Errorf("ParsePAcker error. %s", err)
	}
	if pkt.Ffpkt != nil {
		t.Errorf("ParsePacket unmatch. ffpkt=%v", pkt.Ffpkt)
	}
	if v := pkt.Data; v == nil {
		t.Errorf("ParsePacket unmatch. data=%v", v)
	}
	if v := bytes.Compare(pkt.Data, data); v != 0 {
		t.Errorf("ParsePacket unmatch. cmp=%v", v)
	}
}

func TestParsePacketFFPkt(t *testing.T) {
	data := []byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x19,
		0x06, 0xea, 0xb8, 0xc1, 0x0a, 0x0a, 0x00, 0x00, // eth_type:0x0a0a, pad:[2]byte
		0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, // reid: "ABCDEFGH"
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
		0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
		0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	}

	pkt, err := ParsePacket(data, 1)
	if err != nil {
		t.Errorf("ParsePAcker error. %s", err)
	}
	if v := pkt.Data; v != nil {
		t.Errorf("ParsePacket unmatch. data=%v", v)
	}
	if pkt.Ffpkt == nil {
		t.Errorf("ParsePacket unmatch. ffpkt=%v", pkt.Ffpkt)
	}
	if v := pkt.Ffpkt.GetReId(); v != "ABCDEFGH" {
		t.Errorf("ParsePacket unmatch. re_id='%s'", v)
	}
	if v := pkt.Ffpkt.GetIfname(); v != "abcdefghijklmnopqrstuvwx" {
		t.Errorf("ParsePacket unmatch. ifname='%s'", v)
	}
}
